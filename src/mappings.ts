import {
    Burn,
    Mint,
    User,
    Vault,
    Loan,
    Auction,
    NFTLiquidated,
    NFTSeized
} from "../generated/schema";
import {Address, Bytes} from "@graphprotocol/graph-ts";
import {
    Minted as MintedEvent,
    Burned as BurnedEvent,
    Transfer as TransferEvent,
    Loaned as LoanedEvent,
    AuctionStarted as AuctionStartedEvent,
    NFTSeized as NFTSeizedEvent,
    NFTLiquidated as NFTLiquidatedEvent,
    RangeProtocolBlurVault,
} from "../generated/RangeProtocolBlurVault/RangeProtocolBlurVault";
import {bn, ZERO} from "./common";

/**
 * @dev Handles the recording of new mints happenings on the vault.
 *
 * Updates the underlying balances and liquidity amount.
 *
 * @param event Instance of MintedEvent.
 */
export function handleMinted(event: MintedEvent): void {
    const vault = getOrCreateVault(event.address);
    if (vault.firstMintAtBlock.equals(ZERO)) {
        vault.firstMintAtBlock = event.block.number;
        vault.save();
    }

    const mint = new Mint(vault.id.toHexString() + "#" + vault.lastMintIndex.toHexString().substr(2));
    mint.receiver = event.params.to;
    mint.mintAmount = event.params.shares;
    mint.amountIn = event.params.depositAmount;
    mint.timestamp = event.block.timestamp;
    mint.vault = vault.id;
    mint.save();
    vault.lastMintIndex = vault.lastMintIndex.plus(bn(1));
    
    const user = User.load(event.params.to)!;
    user.token = user.token.plus(event.params.depositAmount);
    user.save();

    updateUnderlyingBalances(vault);
}

/**
 * @dev Handles the recording of new burns happenings on the vault.
 *
 * Updates the underlying balances and liquidity amount.
 *
 * @param event Instance of BurnedEvent.
 */
export function handleBurned(event: BurnedEvent): void {
    const vault = getOrCreateVault(event.address);
    const burn = new Burn(vault.id.toHexString() + "#" + vault.lastBurnIndex.toHexString().substr(2));
    burn.receiver = event.params.from;
    burn.burnAmount = event.params.shares;
    burn.amountOut = event.params.withdrawAmount;
    burn.timestamp = event.block.timestamp;
    burn.vault = event.address
    burn.save();

    vault.lastBurnIndex = vault.lastBurnIndex.plus(bn(1));
    updateUnderlyingBalances(vault);
}

/**
 * @dev Called when vault shares are minted, burned or transferred. It updates the user's balance in a given
 * vault(event.address). The user's balance for a given vault is stored in the entity UserVaultBalance, the id
 * of which is being generated by concatenating the vault's id and user's address, so the data could structured
 * where users' data across different vaults could be tracked.
 *
 * Updates the underlying balances and liquidity amount.
 *
 * @param event Instance of TransferEvent.
 */
export function handleTransfer(event: TransferEvent): void {
    const vaultId = Bytes.fromByteArray(event.address);
    let token = ZERO;
    if (event.params.from != Address.zero()) {
        const fromUser = User.load(event.params.from)!;
        token = fromUser.token.minus(
            fromUser.token
                .times(fromUser.balance.minus(event.params.value))
                .div(fromUser.balance)
        );

        fromUser.balance = fromUser.balance.minus(event.params.value);
        fromUser.token = fromUser.token.minus(token);
        fromUser.save();
    }

    if (event.params.to != Address.zero()) {
        let user = User.load(event.params.to);
        if (user == null) {
            user = new User((event.params.to));
            user.save();
        }

        let toUser = User.load(event.params.to);
        if (toUser == null) {
            toUser = new User(event.params.to);
            toUser.balance = event.params.value;
            toUser.token = ZERO;
            toUser.vault = vaultId;

            const vault = getOrCreateVault(event.address);
            vault.lastUserIndex = vault.lastUserIndex.plus(bn(1));
            vault.save();

            toUser.userIndex = vault.lastUserIndex;
        } else {
            toUser.balance = toUser.balance.plus(event.params.value);
        }

        if (event.params.from != Address.zero()) {
            toUser.token = toUser.token.plus(token);
        }
        toUser.save();
    }

    updateUnderlyingBalances(getOrCreateVault(event.address));
}

export function handleLoaned(event: LoanedEvent): void {
    const vault = getOrCreateVault(event.address);
    vault.lastLoanIndex = vault.lastLoanIndex.plus(bn(1));

    const loan = new Loan(vault.lastLoanIndex.toHexString());
    loan.lienId = event.params.lienId;
    loan.amount = event.params.amount;
    loan.timestamp = event.block.timestamp;
    loan.vault = vault.id;
    loan.save();

    updateUnderlyingBalances(vault);
}

export function handleNFTLiquidated(event: NFTLiquidatedEvent): void {
    const vault = getOrCreateVault(event.address);
    vault.lastLiquidatedNFTIndex = vault.lastLiquidatedNFTIndex.plus(bn(1));

    const nftLiquidated = new NFTLiquidated(vault.lastLiquidatedNFTIndex.toHexString());
    nftLiquidated.collection = event.params.collection;
    nftLiquidated.tokenId = event.params.tokenId;
    nftLiquidated.amount = event.params.amount;
    nftLiquidated.recipient = event.params.recipient;
    nftLiquidated.timestamp = event.block.timestamp;
    nftLiquidated.vault = vault.id;
    nftLiquidated.save();

    updateUnderlyingBalances(vault);
}

export function handleAuctionStarted(event: AuctionStartedEvent): void {
    const vault = getOrCreateVault(event.address);
    vault.lastAuctionIndex = vault.lastAuctionIndex.plus(bn(1));

    const auction = new Auction(vault.lastAuctionIndex.toHexString());
    auction.collection = event.params.collection;
    auction.tokenId = event.params.tokenId;
    auction.lienId = event.params.lienId;
    auction.timestamp = event.block.timestamp;
    auction.vault = vault.id;
    auction.save();

    updateUnderlyingBalances(vault);
}

export function handleNFTSeized(event: NFTSeizedEvent): void {
    const vault = getOrCreateVault(event.address);
    vault.lastSeizedNFTIndex = vault.lastSeizedNFTIndex.plus(bn(1));

    const nftSeized = new NFTSeized(vault.lastSeizedNFTIndex.toHexString());
    nftSeized.collection = event.params.collection;
    nftSeized.tokenId = event.params.tokenId;
    nftSeized.lienId = event.params.lienId;
    nftSeized.timestamp = event.block.timestamp;
    nftSeized.vault = vault.id;
    nftSeized.save();

    updateUnderlyingBalances(vault);
}

/**
 * @dev It updates the underlying balances of the vault on token0 and token1.
 * The underlying balances include all the funds held by vault excluding the manager and treasury fees.
 *
 * It also updates the liquidity amount currently held by vault and finalize the vault's updates by saving in the updates
 * in subgraph store.
 *
 * @param vault Instance of vault of being updated.
 */
function updateUnderlyingBalances(vault: Vault): void {
    const vaultInstance = RangeProtocolBlurVault.bind(Address.fromBytes(vault.id));
    vault.totalSupply = vaultInstance.totalSupply();

    vault.underlyingBalance = vaultInstance.getUnderlyingBalance();
    vault.ownedDebt = vaultInstance.getCurrentlyOwnedDebt();
    vault.save();
}

function getOrCreateVault(vaultAddress: Address): Vault {
    let vault = Vault.load(vaultAddress);
    if (vault != null) {
        return vault;
    }
    const vaultInstance = RangeProtocolBlurVault.bind(Address.fromBytes(vaultAddress));
    vault = new Vault(vaultAddress);
    vault.blurPool = vaultInstance.blurPool();
    vault.blend = vaultInstance.blend();
    vault.totalSupply = ZERO;
    vault.manager = vaultInstance.manager();
    vault.managingFee = vaultInstance.managerFee();
    vault.firstMintAtBlock = ZERO;
    vault.underlyingBalance = ZERO;
    vault.ownedDebt = ZERO;
    vault.lastMintIndex = ZERO;
    vault.lastBurnIndex = ZERO;
    vault.lastUserIndex = ZERO;
    vault.lastLoanIndex = ZERO;
    vault.lastAuctionIndex = ZERO;
    vault.lastSeizedNFTIndex = ZERO;
    vault.lastLiquidatedNFTIndex = ZERO;
    vault.save();
    return vault;
}
